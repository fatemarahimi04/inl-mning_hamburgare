Names of everyone in the team:
Fatema, Masumeh, and Rezvaneh
Link to serve:
https://github.com/fatemarahimi04/inl-mning_hamburgare.git 

For testing and debugging, we focused on checking the functionality of the burger ordering system. This included verifying that the customer can view burgers, prices and ingredients as well as remove items from their order. We also tested the connection between the orderer and the kitchen view to ensure orders were properly sent and received. Additionally, we worked on debugging issues with our database setup and fixed errors in the Dockerfiles to ensure the system worked smoothly.
The first idea was to test opening a menu where the customer could choose to remove ingredients they didn´t want from the item. This was a bit too advanced for us because it required JavaScript and we weren´t very familiar with it. We changed our approach to something simpler and more efficient. The simpler idea was to list ingredients next to each item using checkboxes, allowing the customer to uncheck the ingredients they didn´t want. I retrieved the list of ingredients from my database. I sent the information in a form using the POST method to the kitchen view. For testing, I wrote a simple HTML code just to make it work, as the assignment mentioned that functionality was more important than visualization.
Flask uses port 5000 and to avoid conflicts, I assigned port 5000 to the burger orderer and port 5001 to the kitchen view. I did this to have two web pages I could work on. I realized this when I tried running both the burger orderer and kitchen view in port 5000, which didn´t work. Sometimes, when I ran too many things in the terminal it froze and stopped working and the easy solution was to restart VS code. An example is that I had the module installed in my environment, ye I still received a “no module found” error, even though it was installed. 
We learned a big lesson that even the smallest change in one file can have a significant impact on other parts of the code in different files. 

In our tests for the burger and kitchen applications we focuced on ensuring that the functionality worked as expected and that communication between the interfaces was correct. We used modules such as json to format data into JSON and app from both app and app_kitchen t initiate the Flask test clients. This allowed us to simulate HTTP request in a controlled test enviroment. 

To structure the tests in the kitchen application so we used unittest and created a test class called KitchenViewTestCase which provided an organized and efficient way to set up and run our test cases. Inside this class we used the setUp() method to initialize the test client before each test case ran, ensuring that each specific function was tested in an isolated enviroment. 

We then used post ang get methods to send POST ang GET request to the different API endpoints. To verify that the server handled the data correctly we used asserEqual and assert to compare actual results with expected ones. For example, we checked that the server responded with correct status codes and that specific messages were returned accurately.

The first idea was to test opening a menu where the customer coild choose to remove ingredients they didn't want from the item. This was a bit too advanced for us beacuse it required JavaScript, whick we weren't very familiar with. We changed our approach to something simpler and more efficent. Instead of that we decided to list ingredients next to each item using checkboxes, allowing the customer to uncheck ingredients they didn't wannt. We retrieved the list of ingredients from our database and then sent the information in a form using the POST method to the kitchenview. To make it functional for testing we decided to wrote a simple HTML setup as the assignmeny mentioned that functionality was more important than visualization. 

In the burger application, we bagan by testing the / endpoint:
- For the GET request in the test_index_get test we confirmed that    the home page was accessible and responded with status code 200.
- For the POST request, in the test_order_post test we sent an order in JSON format that included details about the burger (name, price and excluded ingredients). We checked that the server responded with status code 200 and returned the message 'Order sent successfully!'

Next step was testing the kitchen application's /order endpoint:
- Using POST in test_receive_order, we sent a similar order and confirmed that the server responded with status code 200.
-We also tested GEt request to /order in test_invalid_method to ensure that this endpoint only accepts POST requests. When we sent a GET request we expected and received a status code of 405 (Method Not Allowed) clearly indicating that the method was not allowed here.

Additionally to avoid port conflicts, we assigned port 5000 to the burgerorderer and port 5001 to the kitchenview allowing both to run simultaneously. We realized this was necessery after initially trying to run both on port 5000 which didn't work. Sometimes when running multiple processes in the terminal it would freeze and stop working, a quick restart of VS Code solved the issue. Another minor challenge was encountering a "no module found" error, even though the module was installed in the enviroment.

 Through these tests, we confirmed that the applications correctly handled both order functions and methos restrictions. All requests returned expected responses and we confirmed that the applications could manage incorrect methods (such as GET on /order) and give proper feedback to the user. We also learned a valueble lesson that even small changes in one file can significantly impact other parts if the code in diffrent files which was crucial for understanding how interconnected our setup is.
 